+++

author = "pikachu"
title = "分布式锁实现及原理"
date = "2022-05-09"
description = "基于数据库，Redis，Zookeeper"
draft = true
tags = [
    "分布式","redis","mysql"
]
categories = [
    "it"
]

+++



## 一、分布式锁的原理

**场景**：多实例的代码块同步（单实例通信基于本机环境，多实例通信借助第三方）

​		锁通常用于做代码块的**同步**，保证同段代码在**多线程**情况下同一时间只能被一个线程执行。Java中用于锁操作的有**Synchronize**和**ReentranLock**，但是两者都是基于单机应用的情况下使用，对于分布式系统，同个服务会有多个实例被启动（例如多实例下保证单个定时任务执行），那么对于这种场景下的代码块同步就不能按常规处理，只能借助第三方让各个实例进行通信，进而达到锁的控制效果，目前分布式锁常见的实现方式有：**基于数据库行锁**、**基于Redis锁**、**基于Zookeeper锁**。

**流程**：多实例做锁的抢占，**加锁**成功的获取到锁并执行相关代码块，此时其他实例获取锁失败，完成操作后**解锁**。





## 二、分布式锁的实现方案及优缺点



> **临界知识**：
>
> - 分布式锁本质上就是多实例的锁抢占问题。



### 1. 基于数据库的分布式锁



#### 实现原理

- 分布式锁在MySQL上的体现本质上就是**多实例间基于数据库表的锁抢占过程**。其中会用到MySQL的一些锁的特性。
- MySQL有哪些锁？
  - 按照锁的粒度分有：**行锁**和**表锁**（都是悲观锁）。InnoDB支持两者，MyIsam只支持表锁。**行锁是基于索引进行的**，如果查询没走索引，则说明需要进行全表扫描，加的也是表锁。
  - 按照锁的功能分有：读锁（共享锁）和写锁（排他锁）。
  - 按照锁的实现方式分有：悲观锁和乐观锁。
- MySQL在执行**Select语句之前会加读锁**，**Delete、Update、Insert语句前会加写锁**（悲观锁）。



#### 实现方式

隐式加锁

- 基于数据库表：直接创建一张表
  - 加锁：向表中插入一条数据（主键或唯一键），插入成功则说明获取到锁。
  - 解锁：删除该行数据

显式加锁

- 悲观锁：在SQL语句中显式做锁竞争

  - 加锁：在语句后面 + for update修改锁状态，修改成功则锁抢占成功
  - 解锁：将锁状态修改回来

  ```
  // 在同个事务中for update的锁会一直持有，该例子只是单实例加锁演示，但是for update确实可以用于锁的抢占。
  
  //0.开始事务
  begin;/begin work;/start transaction; (三者选一就可以)
  //1.查询出商品信息
  select status from t_goods where id=1 for update;
  //2.根据商品信息生成订单
  insert into t_orders (id,goods_id) values (null,1);
  //3.修改商品status为2
  update t_goods set status=2;
  //4.提交事务
  commit;/commit work;
  ```

- 乐观锁：在SQL语句中显式做锁竞争

  - 加锁：update并修改锁状态成功则说明锁抢占成功。（用于做锁抢占的语句本质上没有加锁，不过每次都会校验当前版本，版本号不同则回滚。）
  - 解锁：将锁状态改回则解锁成功

  ```
  1.查询出商品信息
  select (status,status,version) from t_goods where id=#{id}
  2.根据商品信息生成订单
  3.修改商品status为2
  update t_goods 
  set status=2,version=version+1
  where id=#{id} and version=#{version};
  ```



#### 优缺点

- 对数据库依赖，存在
  - 单点故障
  - 不走索引时行锁会变表锁，导致并发性能降低
  - 锁不可以重入



### 2. 基于Redis的分布式锁



#### 实现原理

- Redis是**单线程**的，天生不需要做锁抢占
- 通过其`set nx`命令可以实现**加锁**：当redis中不存在该key时返回成功，否则返回失败
- 通过`px`命令，可以实现**超时解锁**：指定时间后做锁的释放





#### 实现方式

基于Jedis的实现

- 加锁：set NX PX
- 解锁：基于lua脚本，解锁的时候不仅仅是判断key



基于Redisson的实现





基于RedLock算法的实现



### 3. 基于Zookeeper的分布式锁