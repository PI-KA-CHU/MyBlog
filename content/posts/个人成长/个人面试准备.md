# 自我介绍

​		面试官你好，我叫曾博佳，毕业于北京师范大学珠海分校软件工程专业。开发技能上主要以Java语言为主，有扎实的Java基础和良好的编码风格，熟悉并发编程、JVM及锁知识，开发模式上熟悉以SpringBoot、SpringCloud为主的Web开发模式，但是最近有人了解到Go语言，也有意愿学习和转语言。目前的工作经历主要有两段，第一是做国际航运生命周期编排系统开发，特点是采用敏捷开发、微服务开发，采用K8S服务网格做微服务容器编排和部署。第二是在一家交通行业公司做智慧服务区的开发，它的特点主要是物联网、基础设备状态采集、微服务开发。最后做一个自我评价，我是一个比较上进，有较好的自我驱动力及抗压能力，像目前我的状态就处于压力比较大的环境，但是我相信我能够打破这种现状，也希望能够得到反馈，不断修正和提升自我。



# 如何编写简历

- https://juejin.cn/post/6844904034218803214#heading-6



# 面试记录



CVTE一轮面试：

1. JVM
   1. 旧系统的OOM？OOM如何做检测和检查？
   2. 垃圾回收器
      1. 垃圾回收器有哪些？G1和CMS的区别？回收流程是什么？适合在什么场景？
      2. 新生代老年代的垃圾回收策略
   3. 标记-整理和标记-清除的区别？
   4. 做过哪些JVM上的优化？
   5. 如何检查线程数量，可以通过哪些方式去检查？JDK自带哪些工具？

2. 项目
   1. 旧系统为什么要进行拆分？
      1. 出现OOM？哪些OOM？内存泄露？线程创建过多？
      2. 线上部署了几个实例？
      3. 服务耦合，相互影响，版本控制困难。
   2. 微服务监控怎么做的？如何评估服务需要扩容？如何及时发现系统异常情况？
   3. 难点是什么？如何解决的？
   4. 拆分成多少个服务？微服务拆分时间多长？
   5. 数据库也是做了拆分吗？按数据表做垂直拆分？保证数据一致性（分布式事务）
   6. 单表数据量是多大？
   7. 采用了什么消息队列？为什么要用消息队列做服务通信而不用spring cloud？
   8. 项目采用了DDD，在微服务中DDD是如何分层的？
   9. 自己学习了什么知识？应用到项目了吗？
      1. 分布式事务
      2. 分布式ID
      3. redis bitmap
      4. 幂等性处理、有序性处理、可靠性处理
      5. netty nio采集
3. MySQL（回答的还可以）
   1. 如何进行优化？
   2. 索引结构有哪些？
   3. 有做分库分表吗？
   4. MySQL锁有哪些？间隙锁的作用是什么？（隔离级别：可重复读，解决幻读）
   5. 需要重点了解：死锁及解决思路



# 面试准备

## 中间件



### Redis

- 场景：https://www.nowcoder.com/discuss/953289?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=7A239D7C6F1FE3A8AAC731BCD696C405-1655743167774
- 高频面试题：https://www.nowcoder.com/discuss/945665?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=7A239D7C6F1FE3A8AAC731BCD696C405-1655743167774



#### Redis用在什么场景？

- 已用：

  - 缓存统计信息、基础用户信息、接口权限信息
  - 幂等性处理（引出Kafka）
    - 四种解决幂等方案：https://juejin.cn/post/6906290538761158670
    - 卡口车辆驶入，会出现重复消费的问题吗？会有的
      - 比如卡口对同一辆车可能会传多份照片
      - Kafka是autocommit机制
        - 如果消费者还没来得及commit就重启，重启后会从kafka拉取未过更新的offset，则会造成重复消费。
        - 如果commit了，但是MQ宕机导致接收不到，则重启后会重复消费
  - bitmap统计设备在线，减少数据库压力
- 其他
  - 简单消息队列
  - 分布式锁



#### Redis应用到了哪些数据结构（缓存）？

- String（缓存统计数据，提高读性能）
- 哈希（服务区的map作为缓存）
- List（卡口基本数据）



### Netty

- 通俗的理解Netty：https://www.zhihu.com/question/24322387
- *Netty知识：https://juejin.cn/post/6844903703183360008
- 面试题：
  - https://www.nowcoder.com/discuss/832208?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1656053990442
  - https://juejin.cn/post/6999225355374428168
  - 阿里大牛：https://zhuanlan.zhihu.com/p/148726453



#### 什么是Netty

> Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty本质是上对Java NIO的封装，采用Reactor线程模型、零拷贝技术，极大的提升了socket通信性能。



#### Netty的特点

> 高并发、传输快和封装好

- **高并发**：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的**网络通信框架**，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。
- **传输快**：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。
- **封装好**：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。



#### Netty的应用场景？你们项目用在什么地方

> Netty可构建高性能、低延时的各种Java中间件，例如MQ、分布式服务框架等，Netty主要作为基础通信框架提供高性能、低子延时的通信服务;（阿里分布式服务框架 Dubbo、 RocketMQ 默认使用 Netty 作为通讯框架）

- 作为基础设备通信框架，例如采用NIO做情报板、水电表数据采集



#### Netty的整个处理流程

- 服务端

![img](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/166cf93e830044e7%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp)

![img](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/166cf9418d4c86e4%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp)



- 客户端

![img](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/166cf957e59b5066%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp)



#### NIO、BIO、AIO的区别

- https://juejin.cn/post/6844903687626686472

- 衍生：Linux的五种IO模型的区别（磁盘IO）

![image-20220705103107463](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220705103107463.png)

- Java中三种IO模型的区别（BIO、NIO、AIO）

  > Java中的三种IO模型都是依赖操作系统IO进行的封装，

  - BIO：**同步阻塞型IO**（1请求1线程连接），连接建立后用户线程发起IO请求，系统切换到内核态读取磁盘数据到内核缓冲区，此过程中用户线程阻塞等待直到内核缓冲区数据读取完成，再将其复制到用户态缓冲区（再到socket缓冲区）

  - NIO：**同步非阻塞型IO**（多请求1线程连接），连接建立后，用户线程发起IO请求并注册到selector（多路复用器）中，注册完用户线程返回，由Selector（ Selector 其实就是 select/poll/epoll 的外包类）中的线程去检查多路连接的IO是否准备就绪，完毕则调用用户线程将内核缓冲区的数据复制到用户缓冲区。与上面的Linux模型中的普通NIO（不断轮询查看）不同，Java中的NIO是【多路复用IO+信号量IO】，大大减少用户线程的消耗，但是数据从内核到用户的复制仍然由用户线程执行，所以本质上仍然是同步的。

    ![image-20200610173230680](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20200610173230680.png)

  - AIO：**非同步非阻塞型IO**。与同步型IO不同，内核态到用户态的数据复制在AIO中直接由内核线程负责处理，所以对于用户线程来说，是异步执行的。



#### Netty的线程模型了解吗？

答：Reactor模式是基于事件驱动开发的，核心组成部分包括Reactor和线程池，其中Reactor负责监听和分配事件，线程池负责处理事件，而根据Reactor的数量和线程池的数量，又将Reactor分为三种模型。

- 单线程模型 （单Reactor单线程）
- 多线程模型 （单Reactor多线程）
- 主从多线程模型 （多Reactor多线程) 

> Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个 线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的 accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read 和write事件，由对应的Handler处理。



三种模型详细介绍（挑重点记忆，我面试没遇到过让详细说的。）

- **单线程模型**：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都 是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连 接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的 链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高 负载、大并发的应用场景不合适。
- **多线程模型**：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和 发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线 程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。
- **主从多线程模型**：Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上， 用于处理I/O 的读写等操作，从而保证mainReactor只负 责接入认证、握手等操作；



#### TCP 粘包/拆包的原因及解决方法？

> 答：TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。

原因：

- 应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络 上，这将会发生粘包现象；

解决：

- FixedLengthFrameDecoder：定长拆包器
- LineBasedFrameDecoder：行拆包器
- DelimiterBasedFrameDecoder：自定义分隔符分割器
- LengthFieldBasedFrameDecoder：基于长度域拆包器





#### 什么是零拷贝，跟传统拷贝的区别？

- *https://blog.csdn.net/liyifan687/article/details/106749460
- *https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/16%20%20IO%20%E5%8A%A0%E9%80%9F%EF%BC%9A%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%E7%9A%84%20Netty%20%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.md
- *https://www.pdai.tech/md/java/io/java-io-nio-zerocopy.html#%E5%85%B6%E5%AE%83%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0
- https://juejin.cn/post/6939881308114354207



**什么是零拷贝**

> 零拷贝是个广义上的概念，可以认为只要能够减少不必要的 CPU 拷贝，都可以理解为是零拷贝。常见的零拷贝优化有以下：
>
> - 操作系统级别的零拷贝
> - 用户态的数据操作优化
>
> DMA： 全称叫直接内存存取（Direct Memory Access），是一种允许外围设备直接访问系统主存的机制。DMA 接管了数据读写的工作，不需要 CPU 再参与 I/O 中断的处理，从而减轻了 CPU 的负担。



**一次传统磁盘IO的过程**

> 磁盘 - 内核 - 用户空间（一次读写时共涉及了4次上下文切换，2次 DMA 拷贝以及2次 CPU 拷贝。）	

![screen-1535441](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/screen-1535441.png)

- 一次网络IO的过程：web服务区 - 内核 - 用户空间 - 网卡（如果web服务器涉及磁盘IO，则还需要添加磁盘IO过程）![image-20220705102442286](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220705102442286.png)



**零拷贝实现**

- **用户态直接IO**：用户空间直接访问硬件设备，通过DMA进行数据传输

![screen-1535947](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/screen-1535947.png)

- **mmap**：MMAP 是数据不会到达用户空间内存，只会存在于系统空间的内存上，用户空间与系统空间共用同一个缓冲区，两者通过映射关联。（发生了 4 次上下文切换 + 1 次 CPU 拷贝 + 2 次 DMA 拷贝）

![screen-1773287](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/aHR0cDovL2ltZy5sbGM2ODcudG9wL3VQaWMvc2NyZWVuLTE3NzMyODcucG5n)

- **sendfile**： Linux 2.4 版本开始，减少了内核缓冲区到Socket缓冲区的一次CPU拷贝，采用传输数据描述信息，由网卡DMA直接进行内核缓冲区的数据拷贝。与 mmap 内存映射方式不同的是， sendfile() 调用中数据对用户空间是完全不可见的，可以认为是对nmap的优化。（sendfile再JDK的封装中即`FileChannel#transferTo`方法）

  ![image-20200610154454498](https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20200610154454498.png)



**Netty的零拷贝优化**

> Netty的零拷贝技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化。

- **堆外内存**：Netty发送和接收消息主要使用bytebuffer，bytebuffer使用堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。
- **Composite Buffers**：传统的bytebuffer，如果要合并两个bytebuffer，需要创建一个2*n大小的新数组，再将两个拷贝到新数组中，而Composite Buffers没有真正将多个bytebuffer组合起来，而是保存了他们的引用。
- **FileChannel.transferTo**：Netty底层调用了FileChannel的transferTo方法，该方法即上述的sendfile方式的零拷贝，是操作系统级别的零拷贝技术。





---



### Kafka



Kafka用在什么场景？

- Kafka用于接收情报板、事件检测及其他设备采集的消息，用于与系统服务的解耦，可用做流量控制
- 情报板发送需要保证**有序性**，防止情报板覆盖，采用情报板code作为partitionKey，防止乱序导致的覆盖问题。
- 卡口数据接收需要**防止消息丢失**，采用手动ack机制，保证业务正常后再提交ack。
- Kafka采用最大努力通知配置，BASE理论，柔性事务最终一致性。
  - PCM采用最大努力通知（柔性事务）：消息异步发送，如果没有收到ack，则重复发送，本地重复失败后发送到Exception Queue，由Exception Queue再隔一段时间进行发送，并且会邮件通知相关人员排查。
    - https://juejin.cn/post/7023620718692663326

  - 服务区采用本地消息表：发布情报板后，异步返回发布成功，由于消息可能会丢失（发送端、传输过程等），故采用本地消息表，事务插入发布记录及发布的消息（消息及其状态），如果消息被正常处理后，则返回执行结果修改本地消息表中的发布状态。由于定时任务会定时检测消息状态，如果发布失败，则重新发送。
    - https://juejin.cn/post/6844904041659498509

- Kafka的重复消费问题：幂等性处理
  - https://juejin.cn/post/7002778713943343117
- *Kafka性能、可靠性问题
  - https://juejin.cn/post/7018702635544870948
- Kafka扫盲
  - https://juejin.cn/post/7012815379772768264#heading-3



目前系统可能存在的问题：

1. 如果卡口车辆进入后，业务代码异常，导致消息丢失，如何处理？（车辆实际进去了，但是车位占用数据没有录入，并且卡口消息被消费了）
   1. 开启手动ack机制，业务完成后再ack，防止消息丢失
   2. 重复消费问题：redis幂等处理，数据库唯一键处理
2. 如果前面正常，但是在发布情报板的时候异常，导致消息没发送出去，如何处理？
   1. 采用本地消息表，存储消息状态，防止消息丢失



手动提交ack和本地消息表的区别：

- 手动提交ack主要用于防止业务异常导致消息没有被正常消费的问题，而不能保证消息在传输过程中的其他问题（例如*上游服务宕机导致消息没有被发送、MQ宕机导致消息直接丢失等的问题，MQ可以有副本机制，但是也是最大程度的去避免丢失问题）
  - 服务区应用：卡口车辆通过手动ack，防止业务异常导致消息丢失，进而导致车辆出入卡口数据不能被更新，停车位识别出现问题。
- 本地消息表则可以确保**最终一致性原则**（无论如何都会可以保证数据最终一致），因为其原理是在入口处就保存了请求，例如支付后先通过事务【执行支付业务并插入本地消息表】，然后发送支付消息到MQ，通过定时任务监控本地消息表保证后续业务正常执行（后续业务执行成功后会发MQ做确认），发现还没有完成则重新发送MQ，因此存在重复消费问题，需要对接口做幂等处理。
  - 服务区应用：情报板发布后插入情报板相关业务数据，需要发送情报板更新的消息到另一个服务进行对接更新，如果消息在过程丢失，将会出现情报板已经发布但是没有更新的情况，因此引入本地消息表，事务【执行业务数据+插入本地消息表】，通过定时任务查看该条消息对应的需要更新的业务是否已经完成，没有完成则重新发送。



## Java

### Java并发编程



线程：

1. Java中线程的状态有哪些？

2. 创建线程的方式有哪些？关闭线程的方法是什么？

3. 守护线程是什么？

4. 线程、进程和协程的区别

   1. 为什么协程的性能好（GO）

5. *线程、进程的中断过程是怎么样的？

6. 说说sleep、wait方法的区别（引出线程间状态的变换）

   

多线程

1. 怎样理解线程安全？

2. *线程的同步方式

3. *线程间的如何进行通信？

4. 多线程开发过吗？通信方式有哪些？

5. 多线程的理解（why、what、how，引出threadlocal、并发集合、volitile、同步方式（锁））

6. 多进程(继承什么, 不继承什么)，进程间的通信

7. 线程池

   1. *常见的线程池有哪几种？如果线程池爆了会怎样？ - ？

   2. 实现线程池，你觉得核心是什么

   3. 线程池及参数，maximumSize 怎么达到；（线程池拒绝策略、核心线程等原理）

   4. 线程池相关工具类介绍

      

线程同步（锁） 

- Java有哪些锁，分别适用于哪些场景
- synchronized：
  - 锁（synchronized 和 Lock），synchronized 加到普通方法和静态方法的区别，一个类的两个方法都加了 synchronized，是一个锁还是两个锁； - ？
  - synchronized的方法同步和代码块同步区别
  - 类加锁，static方法加锁是加锁什么对象
- CAS：
  - ABA问题如何解决



并发类

- ThreadLocal 用过吗？底层如何实现的？作用是什么？应用场景？ *  2
- 用过原子类吗？答AtomicInteger，问它的原理；
- 说说volitile
- 并发集合（引出集合类）



### JVM

- **对象从产生到消亡的过程**（类加载、内存分配、对象创建、代码运行、GC（垃圾标识、垃圾回收）



GC：

- Minor gc 、Major gc和full gc的区别
- 堆内存的垃圾回收算法（引出垃圾标识算法、垃圾回收器）
- Full GC场景
- 说一下GC
- GC机制



JVM调优

- 有过调优经验吗



JMM

- 描述一下Java内存模型
  - JVM操作栈
  - 本地方法栈
  - 程序计数器
  - 堆
  - 元方法区（引出类加载过程）
- Java的内存分配过程
- HotSpot 中的持久代指的是哪个分区？
- 堆的分区是怎样的？（引出对象从young区到old区到整个过程，接着引出GC）
- Java堆栈的区别
- *什么情况下会发生OOM？（除了代码问题外，可以引出GC问题）
  - 遇到过内存泄漏问题吗？

类加载机制

- 关于JVM 类加载器机制








## 我要问的

1. 请问是外包吗？
2. 请问一共有几轮面试？多久会有结果通知？
3. 请问部门做的项目主要是什么类型的





## 面试题

### CVTE

- https://www.nowcoder.com/discuss/917826?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1654668824810
- https://www.nowcoder.com/discuss/857854?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1654668824810
- https://www.nowcoder.com/discuss/917826?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
- https://www.nowcoder.com/discuss/827803?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
- https://www.nowcoder.com/discuss/786302?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
- https://www.nowcoder.com/discuss/779334?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
- https://www.nowcoder.com/discuss/627151?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack



### 金山

- WPS：https://www.nowcoder.com/discuss/experience/company?tagId=1046
  - https://www.nowcoder.com/discuss/73974
  - https://www.nowcoder.com/discuss/659778?source_id=&channel=
  - https://www.nowcoder.com/discuss/657896?source_id=&channel=
  - https://www.nowcoder.com/discuss/635511?source_id=&channel=
  - https://www.nowcoder.com/discuss/634811?source_id=&channel=
  - https://www.nowcoder.com/discuss/584694?source_id=&channel=
  - https://www.nowcoder.com/discuss/546327?source_id=&channel=
  - https://www.nowcoder.com/discuss/540803?source_id=&channel=
  - https://www.nowcoder.com/discuss/797239?source_id=&channel=

- 金山云：https://www.nowcoder.com/discuss/experience/company?tagId=1003
  - https://www.nowcoder.com/discuss/98899?source_id=&channel=
  - https://www.nowcoder.com/discuss/94884?source_id=&channel=
  - https://www.nowcoder.com/discuss/93663?source_id=&channel=



### 牛客网其他

- *https://www.nowcoder.com/discuss/855750?source_id=profile_create_nctrack&

